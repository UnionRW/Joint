package cn.tesseract.union.asm;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;

import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.security.ProtectionDomain;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

public class HookClassTransformer implements ClassFileTransformer {

    public HookLogger logger = new HookLogger.SystemOutLogger();
    public HashMap<String, List<AsmHook>> hooksMap = new HashMap<>();
    public final HookContainerParser containerParser = new HookContainerParser(this);
    public ClassMetadataReader classMetadataReader = new ClassMetadataReader();

    public void registerHook(AsmHook hook) {
        if (hooksMap.containsKey(hook.getTargetClassName())) {
            hooksMap.get(hook.getTargetClassName()).add(hook);
        } else {
            List<AsmHook> list = new ArrayList<AsmHook>(2);
            list.add(hook);
            hooksMap.put(hook.getTargetClassName(), list);
        }
    }

    public void registerHookContainer(String className) {
        containerParser.parseHooks(className);
    }

    public void registerHookContainer(byte[] bytecode) {
        containerParser.parseHooks(bytecode);
    }

    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] bytecode) {
        List<AsmHook> hooks = hooksMap.get(className.replace('/', '.'));
        if (hooks != null) {
            Collections.sort(hooks);
            logger.debug("Injecting hooks into class " + className);
            try {
                ClassReader cr = new ClassReader(bytecode);
                ClassWriter cw = new SafeClassWriter(null, loader, ClassWriter.COMPUTE_FRAMES);
                HookInjectorClassVisitor hooksWriter = createInjectorClassVisitor(cw, hooks);
                cr.accept(hooksWriter, ClassReader.EXPAND_FRAMES);
                bytecode = cw.toByteArray();

                for (AsmHook hook : hooksWriter.injectedHooks) {
                    if (hook.injected)
                        logger.debug("Patching method " + hook.getPatchedMethodName());
                    else
                        logger.warning(hook + " not injected!");
                }
                hooks.removeAll(hooksWriter.injectedHooks);
            } catch (Exception e) {
                logger.severe("A problem has occurred during transformation of class " + className + ".");
                logger.severe("Attached hooks:");
                for (AsmHook hook : hooks) {
                    logger.severe(hook.toString());
                }
                logger.severe("Stack trace:", e);
            }

            for (AsmHook notInjected : hooks) {
                if (notInjected.isMandatory()) {
                    throw new RuntimeException("Can not find target method of mandatory hook " + notInjected);
                } else {
                    logger.warning("Can not find target method of hook " + notInjected);
                }
            }
        }
        return bytecode;
    }

    protected HookInjectorClassVisitor createInjectorClassVisitor(ClassWriter cw, List<AsmHook> hooks) {
        return new HookInjectorClassVisitor(this, cw, hooks);
    }
}
